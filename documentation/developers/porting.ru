===========================
Руководство по портированию
===========================

:Авторы:    Johann Samuellson, Matthias Rustler
:Copyright: Copyright © 2007, The AROS Development Team
:Версия:    $Revision$
:Дата:      $Date$
:Статус:    Beta
:ToDo:      Добавить несколько реальных примеров.


.. Содержание:: 

Введение
========

Это руководство рассказывает о портировании под AROS программного обеспечения,
распространяемого с configure или make-скриптами. Это справедливо для большинства
программ с открытым исходным кодом из мира Linux. Данное руководство основано на
`документе`__, написанном Джоаном Самуэллсоном для AmigaOS4.

__ http://www.os4depot.net/index.php?function=showfile&file=document/manual/spots-pfd.lha


Что портировать?
----------------

* Наиболее удобным языком для портирования является C. В C++ отсутствуют некоторые 
  особенности.

* Следите за тем, какие дополнительные пакеты требуют программы, которые вы портируете.
  Нельзя просто портировать приложения, использующие такие наборы графических элементов
  как GTK или Qt. Портировать напрямую можно только программы, работающие в командной
  строке.

* Если вы хотите портировать игру, то посмотрите, не использует ли она `libSDL`__.
  Но остерегайтесь программ, использующих OpenGL.

__ http://www.libsdl.org


Получение SDK
-------------

Наиболее просто портировать программы под AROS из Linux, т.к. для этого обычно
есть все необходимые средства разработки. Смотрите `Руководство разработчика`__ 
для информации о том, как установить SDK.

__ app-dev/introduction.php#compiling-on-linux-with-gcc


Основы
------

Первым же вашим действием будет поиск информации о том, как собирать ваш проект.
Если в корневой директории архива есть файл под названием *configure*, то вы
сможете настроить его под вашу платформу. Как это сделать - описано в следующей
главе.

После того как проект правильно настроен, наступает время для запуска компилятора.
Запустите сборку вашего проекта командой ``make``.

Однако, если файла *configure* нет, то ищите файл под названием *Makefile*.
Исправьте его в соответствии с требованиями AROS и соберите проект командой
``make``.

Если всё скомпилировалось и скомпоновалось, то вы готовы к тестированию портированной
версии вашей программы. Очень часто встречается проблема, когда программа не может
найти свои файлы данных, что приводит к краху. Исправьте пути, как описано в
главе об исправлении путей, и попробуйте снова.

Выполните команду ``strip`` для очистки исполняемого файла от отладочной информации,
для того чтобы сделать их меньше.

Теперь, если всё работает, то загрузите портированную программу на
http://archives.aros-exec.org и http://www.aminet.net!


Как настроить
-------------

Под Linux пакеты с настроечными скриптами обычно устанавливаются в 3 шага::

    ./configure
    make
    sudo make install

Тот факт, что мы используем кросскомпилятор делает настройку под AROS более
сложной, чем, например, под AmigaOS4.

Введите ``./configure --help``, чтобы посмотреть доступные опции настройки. Если
настройка завершается неудачно, можно попытаться отключить некоторые возможности.


Простой пример
--------------

::

    ./configure CC=i386-aros-gcc \
    --build=local --host=i686-aros
    --disable-nls --without-x --without-pic --disable-shared

.. Подсказка::

    Имеет смысл записать опции настройки в текстовый файл. В этом случае мы
    сможем его легко запустить заново, введя ``sh build.sh``. Но перед тем, как
    мы повторно запустим скрипт, необходимо выполнить команду ``rm -f config.cache``,
    для того чтобы вернуть процесс настройки в исходное состояние. 

Пояснения к опциям, которые мы использовали выше:

``CC=i386-aros-gcc``
    Указываем, что мы хотим использовать компилятор для AROS. Иначе мы получим
    исполняемый файл для Linux.

``--build=local --host=i686-aros``
    Указывает скрипту настройки для кросскомпиляции под i686-aros.
    
``--disable-nls --without-x --without-pic --disable-shared`` 
    Отключает некоторые возможности не поддерживаемые в AROS.
    
.. Предупреждение::

    Не выполняйте команду ``sudo make install``, так как тогда ваше приложение 
    будет установлено в Linux по адресу */usr/local*.

Пример на SDL (ручная установка)
--------------------------------

Следующий пример описывает процесс настройки программы `Ltris`__, но он подобен
настройке других SDL приложений::

    ./configure CC=i386-aros-gcc  LDFLAGS="-nix" \
    --prefix=/PROGDIR \
    --build=local --host=i686-aros \
    --disable-nls --without-x --without-pic --disable-shared \
    --with-sdl-prefix=/usr/local/aros-sdk/i386-aros

``LDLAGS="-nix"``
    Включает использование семантики путей, принятой в Linux. Приложения для Linux
    часто используют абсолютные пути для своих файлов данных. Но абсолютные пути
    вроде */usr/local/app* значат для AROS следующее: подняться на один уровень 
    выше, затем перейти в директорию *usr*.
    
``--prefix=/PROGDIR``
    Добавлять ко всем путям префикс */PROGDIR*. Вместе с опцией *-nix* это
    позволяет использовать пути в стиле Linux в процессе компилирования и пути в
    стиле AROS в процессе выполнения.
    
``--with-sdl-prefix=/usr/local/aros-sdk/i386-aros``
    Скрипт настройки вызывает *sdl_config* для нахождения требуемых параметров
    CFLAGS и LDFLAGS для SDL приложений. Без этой опции будет вызываться версия
    *sdl_config* для Linux, которая даст неправильные результаты.
    
После успешного выполнения скрипта настройки и команды *make* мы должны
скопировать исполняемый файл ltris и его файлы данных по такому адресу, где
исполняемый файл найдёт файлы данных::

    ltris
        ltris (binary)
        share
            ltris
                gfx
                sounds

__ http://lgames.sourceforge.net/index.php?project=LTris


Пример на SDL (полуавтоматическая установка)
--------------------------------------------

Мы можем использовать почти такие же опции что и выше::

    ./configure CC=i386-aros-gcc  LDFLAGS="-nix" \
    --prefix=/PROGDIR --bindir=/PROGDIR \
    --build=local --host=i686-aros \
    --disable-nls --without-x --without-pic --disable-shared \
    --with-sdl-prefix=/usr/local/aros-sdk/i386-aros

``--bindir=/PROGDIR`` 
    Отключает создание поддиректории *bin*.
    
Не забудьте опцию *--prefix* иначе это приведёт к установке файлов AROS в
некоторые директории Linux.

Теперь вы можете пересобрать ваш проект (выполните ``make distclean``, запустите
скрипт настройки, выполните ``make``). Теперь нам надо выполнить ``sudo make
install``. Но лучше сначала сделать следующие шаги:

+ sudo mkdir /PROGDIR
+ sudo chmod a+rwx /PROGDIR

Это даст нам возможность получить доступ к */PROGDIR* без прав root'а. Теперь мы
наконец  выполняем ``make install``, что должно установить программу в директорию
*/PROGDIR*. Так как это не слишком подходящее место, то мы скопируем её в место, где
AROS сможет её найти (например, cp -r /PROGDIR~/AROS/games/ltris).

Не забудьте выполнить ``rm -rf /PROGDIR/*`` перед тем, как собирать какой-либо
другой проект.


Распространённые при настройке ошибки 
-------------------------------------

*Я получил ошибку о том, что цель или хост i686-aros не доступен (target or host 
i686-aros isn't available).*

Решение:
  Скрипт *config.sub* возможно, устарел или не существует. Выполните ``autoconf``
  в корневой директории пакета. Если это не поможет, то скопируйте текущую версию
  файла *config.sub* например из */usr/share/automake*.

.. _autoconf: http://ftp.gnu.org/gnu/autoconf/

Я получил вот такую ошибку:
  checking for IMG_Load in -lSDL_image... no

Решение:
  Мы используем компоновку со статическими библиотеками, и должны точно указать,
  с чем компоновать. Поместите эту строку в скрипт настройки::

    LIBS="-lSDL_image $LIBS"

  Для корректной работы SDL_image необходимы ещё несколько библиотек, добавим их::

    LIBS="-lSDL_image -lpng -ljpeg -lz $LIBS"

Я получил вот такую ошибку:
  checking for Mix_OpenAudio in -lSDL_mixer... no

Решение:
  Мы используем компоновку со статическими библиотеками, и должны точно указать,
  с чем компоновать. Поместите эту строку в скрипт настройки::
  
    LIBS="-lSDL_mixer $LIBS"

  Для корректной работы SDL_mixer необходимы ещё несколько библиотек, добавим их::

    LIBS="-lSDL_mixer -lvorbisfile -lvorbis -logg $LIBS"
    
Подобное также часто случается, когда configure ищет SDL_ttf, и теперь вы знаете
почему. Нам надо указать ещё несколько библиотек, кроме тех, от которых
зависит SDL_ttf. Ей необходимы -lfreetype и -lz. Добавьте их самостоятельно в
качестве тренировки.

Если вы добавили необходимые зависимости в скрипт настройки, а он по-прежнему не
работает, то возможно, потеряны файлы в SDK. Например, нет библиотек SDL.

Если скрипт всё ещё не работает и вы уверены, что установили библиотеку, то попробуйте
удалить в скрипте настройки целиком секцию, в которой производится проверка
недостающей библиотеки. Это не рекомендуется и применимо только если исчерпаны
остальные возможности.

Теперь вы готовы к сборке вашего проекта. При портировании приложения из unix
всегда вводите ``make``.


Создание makefile вручную
=========================

Такой makefile можно использовать, если система сборки запутанна, и вы хотите её
немного упростить, изменить в соответствии с вашими нуждами. Обычно вам надо
всего лишь изменить существующий makefile, изменить название компилятора C (иначе
будет создан исполняемый файл для Linux) и добавить несколько ссылок на
необходимые библиотеки.

Далее объясняется, что делают флаги.

CC
    Имя исполнительного файла компилятора языка C.

RM
    Имя команды удаления.

STRIP
    Имя команды strip (используется для удаления отладочной информации из
    исполняемых файлов).

CFLAGS
    Указывает компилятору, где искать включения (includes) (-I) и т.д.

LDFLAGS
    Указывает компоновщику, какие библиотеки подключать (-I) и где их найти (-L).
    
OBJS
    Компилятор (GCC/G++) компилирует объектные файлы (#?.o) из ваших .c файлов,
    которые позже связываются вместе для создания исполняемого файла. Здесь надо
    указать имена объектных файлов.
    
OUTPUT
    Имя конечного исполняемого файла.

::

  CC      = i386-aros-gcc
  RM      = rm
  STRIP   = i386-aros-strip --strip-unneeded --remove-section .comment
  CFLAGS  = -Wall -O2 
  LDFLAGS = -nix -lsmpeg -lSDL_gfx -lSDL_net -lSDL_image -lpng -ljpeg -lz -lSDL_mixer \
            -lvorbisfile -lvorbis -logg -lSDL_ttf -lfreetype -lz -lsdl -lauto -lpthread -lm
  OBJS    = a.o b.o c.o
  OUTPUT  = test.exe

  all: $(OBJS)
          $(CC) $(CFLAGS) $(LDFLAGS) $(OBJS) -o $(OUTPUT) 

  main.o: main.cpp main.h 
          $(CC) $(CFLAGS) -c main.cpp

  strip:
          $(STRIP) $(OUTPUT)
        
  clean:
          $(RM) -f $(OBJS) $(OUTPUT)

Не забудьте, что вам надо использовать символы табуляции перед командами (не пробелы).


Использование системы сборки
============================

Система сборки содержит скрипты для настройки пакетов. Большим преимуществом при
использовании системы сборки является лёгкость портирования
приложения на другие разновидности AROS.

+ %build_with_configure
+ %fetch_and_build
+ %fetch_and_build_gnu_development

Смотрите файл $(TOP)/config/make.tmpl для пояснения к аргументам. В *$(TOP)/contrib/gnu*
уже присутствует большое количество пакетов GNU.


Разное
======

Преобразование путей Unix в пути AROS
-------------------------------------

Как преобразовать пути Unix в пути AROS? Замените *getenv("HOME")* на *"/PROGDIR/"*.

Примеры::

    было: strcpy(path, getenv("HOME"));
    стало: strcpy(path, "/PROGDIR/");

    было: strcpy(home,getenv("HOME"));
    стало: strcpy(home,"/PROGDIR/");

    было: sprintf(rc_dir, "%s/.gngeo/romrc.d", getenv("HOME"));
    стало: sprintf(rc_dir, "%sgngeo/romrc.d", "/PROGDIR/");

Заметьте, что я убрал "/." в последнем примере.

Пути к директориям с данными часто устанавливаются в процессе настройки при помощи
опции *-DDATADIR=*. В этом случае определите его так: *-DDATADIR=/PROGDIR/*.
Также часто директории с данными прописаны в makefile. Найдите в нём опцию
*DATADIR=* и измените её на *DATADIR=/PROGDIR/*.


Определения
-----------

Определения (defines) часто устанавливаются в *config.h*, если что-то настроено
неправильно, то вы можете сколько угодно раз менять настройки, используя *#define*
и *#undef*.

Пример определения, которое подходит для всех разновидностей AmigaOS::

  #ifdef __AMIGA__
          blah blah blah
  #else 
          blah blah blah
  #endif

Пример определения, которое подходит только для AROS::

  #ifdef __AROS__
          blah blah blah
  #else 
          blah blah blah
  #endif

Пример определения, которое подходит для BeOS и AROS::

  #if !defined(__BEOS__) && !defined(__AROS__)

Пример более сложного #ifdef::

  #ifdef GP2X
    char *gngeo_dir="save/";
  #elif defined __AROS__
    char *gngeo_dir="/PROGDIR/save/";
  #else
    char *gngeo_dir=get_gngeo_dir();
  #endif

Некоторые пакеты с открытым исходным кодом уже адаптированы под операционные
системы, подобные Amiga. Если вы найдёте в исходном коде что-нибудь вроде
*#ifdef __AMIGA__*, то можете попытаться добавить определение к опциям настройки
(например, CFLAGS="-nix -D__AMIGA__").


Расшифровка сообщений об ошибках
--------------------------------

Error: No return statement in function returning non-void (Ошибка: Не возвращено значение из функции с непустым возвращаемым значением)
  Функция, которая должна возвращать значение, *не возвращает* его.

Error: Control reaches end of non-void function (Ошибка: Проверка достигла конца функции с непустым возвращаемым значением)
  Достигнут конец функции, которая должна возвращать значения, но не возвращает его.

Error: May be used uninitialized in this function (Ошибка: Возможно используется неинициализированная переменная в этой функции)
  Переменная не была инициализирована.

Warning: implicit declaration of function 'blah blah' (Предупреждение: неявное объявление функции 'blah blah')
  Вам надо подключить файл заголовков.
  
  
Распространённые ошибки
-----------------------

warning: incompatible implicit declaration of built-in function 'exit';
warning: incompatible implicit declaration of built-in function 'abort'::

    решение: #include <stdlib.h>

warning: implicit declaration of function 'strlen';
warning: incompatible implicit declaration of built-in function 'strlen'::

    решение: #include <string.h>

warning: implicit declaration of function 'memcpy';
warning: incompatible implicit declaration of built-in function 'memcpy'::

    решение: #include <string.h>

error: memory.h: No such file or directory::

    решение: #include <string.h>

error: malloc.h: No such file or directory::

    решение: #include <stdlib.h>

warning: incompatible implicit declaration of built-in function 'printf'::

    решение: #include <stdio.h>

warning: implicit declaration of function 'MyRemove'::

    решение: #define MyRemove Remove
    
    
Подсказки и хитрости
--------------------

Как найти строку в тексте используя GREP?

::

  grep -R "здесь текст, который надо найти" *

Как мне сделать DIFF файл с моими изменениями?

::

  diff исходный_файл.c изменённый_файл.c >./исходный_файл.patch

Мой исполняемый файл аварийно завершил работу, как его отладить?
  Смотри `Руководство по отладке <debugging>`_. Вы можете использовать
  sys:utilities/snoopy для отслеживания действий вашего приложения.
  
Как перенаправить сообщения и об ошибках и предупреждения компилятора GCC в
текстовый файл?

::

  make 2>warnings.txt
